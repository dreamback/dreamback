<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
	<title></title>
</head>
<body>
<script type="text/javascript">
// encodeURI 以空格进行编码； decodeURI解码
// encodeURIComponet方法对非字母数字，进行编码；decodeURIComponet解码

// hasOwnProperty()方法可以检测一个属性是存在实例中。
// in 检测一个属性是否在原型中，或是否存在实例中。
// 同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于实例中，还是原型中：

function hasPrototypeProperty(object,name){
　　return !object.hasOwnProperty(nam) && (name in object);
}

Object.prototype.toString.call([])  // "[object Array]"
Object.prototype.toString.call({})  // "[object Object]"
Object.prototype.toString.call(2)   // "[object Number]"
Object.prototype.toString.call('')   //"[object String]"


// 理解原型对象
// 无论什么时候，只要创建了一个函数，就会根据一组特定的规律为该函数创建一个prototype属性，这个属性指向函数的原型。

// 继承
// 1，原型链
function superType(){
     this.property = true;
}
superType.prototype.getSuperValue = function(){
    return this.property;
}
//继承了superType
subType.prototype = new superType();
subType.prototype.getSubType = function(){
    return this.property;
}
/*原型链的问题
给原型添加方法的代码一定要放在替换原型的语句之后。
通过原型链继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链。（原型链被切断）
引用类型的原型属性会被所实例共享。*/

// 2，借用构造函数
function superType(){
   this.color = [‘red’,’blue’,’green’];
}
function subType(){
   superType.call(this);//继承了superType
}
/*
借用构造函数的问题
如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都得在构造函数中定义，因此函数复用就无从谈起。
结合继承
 */
//组合继承---------------------------------------------------------
function superType(name){
   this.name = name;
   this.color = [‘red’,’blue’,’green’];
}
superType.prototype.sayName = functioni(){
   alert(this.name);
}
function subType(name,age){
  superType.call(this,name);//继承了superType
  this.age = age;
}
//继承方法
subType.prototype = new superType();
subType.prototype.sayAge = function(){
  alert(this.age);
}

//-------------------------------------------------------------------
arguments.callee//是一个指向正在执行的函数指针


location 是最有用的BOM对象之一,
window.location.hash     //"#contents";
window.location.host     //"www.wrox.com:80"
window.location.href     //域名
window.location.pathname //"/WileyCDA"
window.location.port     //8080 || ''
window.location.protocol //"http:"
window.location.search   //"?q=javascript" 返回URL的查询字符串。这个字符串以问号开头

</script>	
</body>
</html>